# platform
个人学习使用，本项目是采用2.1.9版本的spingboot作为底层框架学习使用
采用assembly插件进行打包，将deploy下的shell的脚本打包到gz文件当中，
使用者可直接运行对应的*.sh或*.bat脚本集成swagger（丝袜哥）作为接口文档，yml文件支持多数据源配置



# 框架依赖
springboot
redis  -->  redis内存工具
nacos  -->  微服务的管理
rocketmq  --> 异步消息发送
xxl-job --> 调度

#1.rocketmq
 采用rocketmq消息队列的形式进行消息之间的传递，比如邮件发送，后台处理文件的过程，前端不需要做出等待，就响应的逻辑。
 rocketmq默认采用集群方式进行消息传递
 
 设计思路。
    rocketmq有两种监听模式，一种为普通的RocketMQMessageListener监听，需要指定topic,tags，以及相应的consumer，
    提供接口进行消息发送，发送采用异步的方式，发送响应成功，会存数据到数据库。为防止丢包，重发等现象的产生，rocketmq
    自带的默认重发次数两次设置就1次，数据库默认为3次。不同的消费者在订阅同一个topic或tags下，在监听的时候，需要调用接口
    查消息是否被消费，已经消费的topic则跳过逻辑，没有消费的进行逻辑处理，处理失败调用回执接口，告诉消费失败，同样消费
    成功的数据，也需要回执到mq当中，告诉消费成功。对于没有消费失败的数据，采用xxl_job的调度方式，定时从表里获取失败的数据，
    再次放到消息队列当中，等待失败的消费者再次消费，重复上述逻辑，当三次同样的数据消费失败，则启动报警邮件。

# 事务处理
1.编程式事务：手动开启事务，事务处理过程中勿随意return。
2.声明式事务：使用@Transactional,异常抛出，或加上rollbackFor = Exception.class。当无事务方法调用有事务的方法时
事务不会生效，而主方法有事务去调用其他方法，无论被调用的方法有无事务，且是否出现异常（有异常需要能够抛出不被捕获），
都触发事务。
